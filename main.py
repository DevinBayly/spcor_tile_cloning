from typing import Union
import json
from pathlib import Path
import imagehash
import io
import spcor
from pydantic import BaseModel
from fastapi import FastAPI,Response
import ssl
from starlette.middleware.cors import CORSMiddleware
import matplotlib.pyplot as plt
import importlib
import pyvips

import numpy as np

from PIL import Image
class Item(BaseModel):
    name:str 
    price:float
    is_offer: Union[bool,None] = None

app = FastAPI()
ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
ssl_context.load_cert_chain('cert.pem', keyfile='key.pem')
# from fastapi.middleware.cors import CORSMiddleware


size = 15
half = size//2
double=size*2
full = pyvips.Image.new_from_file("usgs.jpg")
#drone=Image.open("drone.jpg").convert("RGB").resize((full.width,full.height))
#part = pyvips.Image.new_from_array(drone)


origins = [
"https://observablehq.com/d/9351d8d8b1eefdf8"
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
from pydantic import BaseModel

class pairlists(BaseModel):
    list_of_pairs: list

class Item2(BaseModel):
    name :str
    
class intpair(BaseModel):
    intpair:list 



@app.get("/hello")
async def send_hello():
    return {"hi":"there"}

@app.post("/items/")
async def create_item(item: Item2):
    return item

def fig_to_bytes():
    buf = io.BytesIO()
    plt.savefig(buf, format='png')
    buf.seek(0)
    return buf.getvalue()
def make_slice(arr):
    col,row = arr.tolist() # this is the order that d3 sends  it's extent

    return slice(*row),slice(*col)


@app.post("/kd_tree",
          responses = {
        200: {
            "content": {"image/png": {}}
        }
    },

    # Prevent FastAPI from adding "application/json" as an additional
    # response media type in the autogenerated OpenAPI specification.
    # https://github.com/tiangolo/fastapi/issues/3258
    response_class=Response
          )
async def do_best_perceptual_fit(pair:intpair):
    # assuming that 15 isi the size like our other example
    bbox = [int(e) for e in spcor.make_bbox_sized(pair.intpair,15)]

    print(bbox)
    slices = spcor.make_slice(bbox)
    print(slices)
    test_tile = full.numpy()[slices]
    tree,map = spcor.create_query_structures(Image.fromarray(full.numpy()),15,random_number=30000)

    ims = spcor.return_mapped_neighbors(test_tile,tree,map,32)
    best = spcor.pick_perceptually_best_neighbor(test_tile,ims,8,45)

    buf = io.BytesIO()
    fig,ax = plt.subplots(1,2)
    ax[0].imshow(test_tile)
    ax[1].imshow(best)
    plt.savefig(buf, format='png')
    # img.save(buf,format="png")
    buf.seek(0)
    return Response(content=buf.getvalue(),media_type="image/png")

@app.get("/image",
          responses = {
        200: {
            "content": {"image/png": {}}
        }
    },

    # Prevent FastAPI from adding "application/json" as an additional
    # response media type in the autogenerated OpenAPI specification.
    # https://github.com/tiangolo/fastapi/issues/3258
    response_class=Response)
async def send_back_im():
    img = Image.open("usgs.jpg")
    buf = io.BytesIO()
    img.save(buf,format="png")
    buf.seek(0)
    return Response(content=buf.getvalue(),media_type="image/png")

@app.post("/colorhash",
          responses = {
        200: {
            "content": {"image/png": {}}
        }
    },

    # Prevent FastAPI from adding "application/json" as an additional
    # response media type in the autogenerated OpenAPI specification.
    # https://github.com/tiangolo/fastapi/issues/3258
    response_class=Response)
async def read_root(pair: pairlists):
    arr = np.array(pair.list_of_pairs).astype("int16")
    print(arr)
    mins = np.min(arr,axis=1)
    maxs = np.max(arr,axis=1)
    arr = np.column_stack([mins,maxs]).T
    print(arr)
    row,col= make_slice(arr)
    print("row,",row)
    print("col",col)
    part = full.crop(col.start,row.start,col.stop-col.start,row.stop-row.start)
    chash = spcor.make_chash(Image.fromarray(part.numpy()),3)
    str_chash = str(chash)
    # load the json lookup table,
    # then get the list of the elements and then provide one of the candidates back

    lut = json.loads(Path("./lut_colorhash_32_3.json").read_text())
    candidates = lut[str_chash]
    # hammming distance this to find the tile that's the most like our selected one
    #prepare for more specific hash now that we've found the initial group
    spec_chash = spcor.make_chash(Image.fromarray(part.numpy()),16)

    cand = candidates[0]
    best_row = cand["row"]
    best_col = cand["col"]
    cand_im = full.crop(best_row,best_col,16,16)
    spec_cand_chash = spcor.make_chash(Image.fromarray(cand_im.numpy()),16)
    dif = spec_chash - spec_cand_chash
    min_dif = dif
    # assume length is greater than 1
    print("candidates list is",len(candidates),"long")
    for cand in candidates[1:]:
        row = cand["row"]
        col = cand["col"]
        cand_im = full.crop(row,col,32,32)
        spec_cand_chash = spcor.make_chash(Image.fromarray(cand_im.numpy()),16)
        dif = spec_chash - spec_cand_chash
        if dif < min_dif:
            print("new min")
            best_row = row
            best_col = col
            min_dif = dif
    print("done with candidates",min_dif)

    replacement = full.crop(best_row,best_col,32,32)
    buf=io.BytesIO()
    plt.imshow(replacement.numpy(),cmap="viridis")
    plt.savefig(buf, format='png')
    buf.seek(0)
    return Response(content=buf.getvalue(),media_type="image/png")


@app.post("/",
          responses = {
        200: {
            "content": {"image/png": {}}
        }
    },

    # Prevent FastAPI from adding "application/json" as an additional
    # response media type in the autogenerated OpenAPI specification.
    # https://github.com/tiangolo/fastapi/issues/3258
    response_class=Response)
async def read_root(pair: pairlists):
    arr = np.array(pair.list_of_pairs).astype("int16")
    print(arr)
    mins = np.min(arr,axis=1)
    maxs = np.max(arr,axis=1)
    arr = np.column_stack([mins,maxs]).T
    print(arr)
    row,col= make_slice(arr)
    print("row,",row)
    print("col",col)

    part = full.crop(col.start,row.start,col.stop-col.start,row.stop-row.start)
    # converted = spcor.pack_single_channel(part)
    buf = io.BytesIO()
    # # # Image.fromarray(part).save(buf,format="png")
    # spcor_arr = full.spcor(pyvips.Image.new_from_array(converted)).numpy()
    # print(spcor_arr)
    # print()
    # print("done with spcor")
    plt.imshow(part.numpy())
    plt.savefig(buf, format='png')
    buf.seek(0)

    return Response(content=buf.getvalue(), media_type="image/png")








